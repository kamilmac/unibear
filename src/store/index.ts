import { create } from "npm:zustand";
import { streamOpenAIResponse } from "../services/openai.ts";
import * as clippy from "https://deno.land/x/clippy/mod.ts";
export type ChatItemType = "user" | "ai" | "injector";
import chalk from "npm:chalk";
import { marked } from "npm:marked";
import { markedTerminal } from "npm:marked-terminal";

marked.use(markedTerminal());

const PLACEHOLDER = `
## HI

Rust crate for cooking up terminal user interfaces
(TUIs). It provides a simple and flexible way to create text-based user interfaces in the terminal,
which can be used for command-line applications, dashboards, and other interactive console programs.

## Quickstart

Ratatui has [templates] available to help you get started quickly. You can use the
[\`cargo-generate\`] command to create a new project with Ratatui:

\`\`\`shell
cargo install --locked cargo-generate
cargo generate ratatui/templates
\`\`\`

Selecting the Hello World template produces the following application:

\`\`\`rust
use color_eyre::Result;
use crossterm::event::{self, Event};
use ratatui::{DefaultTerminal, Frame};

fn main() -> Result<()> {
    color_eyre::install()?;
    let terminal = ratatui::init();
    let result = run(terminal);
    ratatui::restore();
    result
}

fn run(mut terminal: DefaultTerminal) -> Result<()> {
    loop {
        terminal.draw(render)?;
        if matches!(event::read()?, Event::Key(_)) {
            break Ok(());
        }
    }
}

fn render(frame: &mut Frame) {
    frame.render_widget("hello world", frame.area());
}
\`\`\`

## Documentation

- [Docs] - the full API documentation for the library on docs.rs.
- [Ratatui Website] - explains the library's concepts and provides step-by-step tutorials.
- [Ratatui Forum] - a place to ask questions and discuss the library.
- [Widget Examples] - a collection of examples that demonstrate how to use the library.
- [App Examples] - a collection of more complex examples that demonstrate how to build apps.
- [Changelog] - generated by [git-cliff] utilizing [Conventional Commits].
- [Breaking Changes] - a list of breaking changes in the library.

You can also watch the [EuroRust 2024 talk] to learn about common concepts in Ratatui and what's
possible to build with it.

## Templates

If you're looking to get started quickly, you can use one of the available templates from the
[templates] repository using [\`cargo-generate\`]:
`;

export type ChatItem = {
  id: number;
  content: string;
  parsedContent: string[];
  contentOverride?: string[];
  type: ChatItemType;
  title?: string;
  hasCode?: boolean;
  selected?: boolean;
  status?: string;
};

type OperationMode = "insert" | "normal";

type Store = {
  init: () => void;
  dimensions: {
    cols: number;
    rows: number;
  };
  filesInContext: string[];
  addFileToContext: (filePath: string) => void;
  operationMode: OperationMode;
  setOperationMode: (mode: OperationMode) => void;
  systemMessage: string;
  textArea: string;
  setTextArea: (text: string) => void;
  chat: ChatItem[];
  onSubmitUserPrompt: (prompt: string) => void;
  appendChatItem: (
    content: string,
    type: ChatItemType,
    contentOverride?: string,
  ) => ChatItem[];
  isStreamingResponse: boolean;
  injectClipboard: () => void;
  tokensInput: number;
  tokensOutput: number;
  injectContext: (content: string, contentOverride: string) => void;
};

let latestChatItemId = 0;

const getNewChatItemId = () => ++latestChatItemId;

export const useStore = create<Store>((set, get) => ({
  init: () => {
    // Enter alt screen
    Deno.stdout.writeSync(new TextEncoder().encode("\x1b[?1049h"));
    const setDimensions = () => {
      const { columns, rows } = Deno.consoleSize();
      set({ dimensions: { cols: columns, rows } });
    };
    Deno.addSignalListener("SIGWINCH", setDimensions);
    setDimensions();
  },
  injectClipboard: async () => {
    get().injectContext(await clippy.readText(), "Injected clipboard content");
  },
  filesInContext: [],
  tokensInput: 0,
  tokensOutput: 0,
  addFileToContext: (filePath) => {
    set({
      filesInContext: [
        ...get().filesInContext,
        filePath,
      ],
    });
    get().appendChatItem("", "injector", `Added ${filePath} to context.`);
  },
  isStreamingResponse: false,
  operationMode: "insert",
  setOperationMode: (mode) => {
    set({ operationMode: mode });
  },
  dimensions: { cols: 0, rows: 0 },
  systemMessage: "",
  textArea: "",
  setTextArea: (text) => {
    set({ textArea: text });
  },
  chat: [],
  appendChatItem: (content, type, contentOverride) => {
    const newChatItem: ChatItem = {
      id: getNewChatItemId(),
      content,
      parsedContent: [],
      type,
    };
    if (contentOverride) {
      newChatItem.contentOverride = contentOverride.split("/n");
    }
    newChatItem.parsedContent = marked.parse(chalk.bgMagentaBright.black(
      "\n " + (newChatItem.contentOverride ?? newChatItem.content) + " ",
    )).split("\n");
    set((state) => ({
      chat: state.chat.concat(newChatItem),
    }));
    return get().chat;
  },
  onSubmitUserPrompt: async (prompt) => {
    let filesContext = "";
    for await (const file of get().filesInContext) {
      const content = await getContentFromFile(file);
      filesContext += `
        File:${file}

        ${content}

      `;
    }
    const chat = get().appendChatItem(prompt, "user");
    const aiChatitem: ChatItem = {
      id: getNewChatItemId(),
      content: "",
      parsedContent: [],
      type: "ai",
    };
    get().setOperationMode("normal");
    set({ isStreamingResponse: true });
    const context = filesContext + chat.map((c) => c.content).join("\n");
    set({
      tokensInput: context.split("  ").filter((char) =>
        char !== " "
      ).join("").length / 3.7,
    });
    await streamOpenAIResponse(
      context,
      (chunk) => {
        aiChatitem.content += chunk;
        aiChatitem.parsedContent = marked.parse(aiChatitem.content).split("\n");
        set({
          chat: [...chat, aiChatitem],
        });
      },
    );
    // get().setOperationMode("insert");
    set({
      isStreamingResponse: false,
      tokensOutput: aiChatitem.content.split("  ").filter((char) =>
        char !== " "
      ).join("").length / 3.7,
    });
  },
  injectContext: (content, contentOverride) => {
    get().appendChatItem(content, "injector", contentOverride);
  },
}));

const getContentFromFile = async (
  filePath: string,
): Promise<string | undefined> => {
  try {
    const fileContent = await Deno.readTextFile(filePath);
    return fileContent;
  } catch (error) {
    console.error("Error reading file: ", error);
  }
};
